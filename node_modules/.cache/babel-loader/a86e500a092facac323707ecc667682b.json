{"ast":null,"code":"const _require = require('@feathersjs/commons'),\n      hooks = _require.hooks,\n      isPromise = _require.isPromise;\n\nconst baseHooks = require('./base');\n\nconst createHookObject = hooks.createHookObject,\n      getHooks = hooks.getHooks,\n      processHooks = hooks.processHooks,\n      enableHooks = hooks.enableHooks,\n      ACTIVATE_HOOKS = hooks.ACTIVATE_HOOKS;\n\nconst withHooks = function withHooks({\n  app,\n  service,\n  method,\n  original\n}) {\n  return (_hooks = {}) => {\n    const hooks = app.hookTypes.reduce((result, type) => {\n      const value = _hooks[type] || [];\n      result[type] = Array.isArray(value) ? value : [value];\n      return result;\n    }, {});\n    return function (...args) {\n      const returnHook = args[args.length - 1] === true ? args.pop() : false; // Create the hook object that gets passed through\n\n      const hookObject = createHookObject(method, {\n        type: 'before',\n        // initial hook object type\n        arguments: args,\n        service,\n        app\n      });\n      return Promise.resolve(hookObject) // Run `before` hooks\n      .then(hookObject => {\n        return processHooks.call(service, baseHooks.concat(hooks.before), hookObject);\n      }) // Run the original method\n      .then(hookObject => {\n        // If `hookObject.result` is set, skip the original method\n        if (typeof hookObject.result !== 'undefined') {\n          return hookObject;\n        } // Otherwise, call it with arguments created from the hook object\n\n\n        const promise = new Promise(resolve => {\n          const func = original || service[method];\n          const args = service.methods[method].map(value => hookObject[value]);\n          const result = func.apply(service, args);\n\n          if (!isPromise(result)) {\n            throw new Error(`Service method '${hookObject.method}' for '${hookObject.path}' service must return a promise`);\n          }\n\n          resolve(result);\n        });\n        return promise.then(result => {\n          hookObject.result = result;\n          return hookObject;\n        }).catch(error => {\n          error.hook = hookObject;\n          throw error;\n        });\n      }) // Run `after` hooks\n      .then(hookObject => {\n        const afterHookObject = Object.assign({}, hookObject, {\n          type: 'after'\n        });\n        return processHooks.call(service, hooks.after, afterHookObject);\n      }) // Run `errors` hooks\n      .catch(error => {\n        const errorHookObject = Object.assign({}, error.hook, {\n          type: 'error',\n          original: error.hook,\n          error,\n          result: undefined\n        });\n        return processHooks.call(service, hooks.error, errorHookObject).catch(error => {\n          const errorHookObject = Object.assign({}, error.hook, {\n            error,\n            result: undefined\n          });\n          return errorHookObject;\n        });\n      }) // Run `finally` hooks\n      .then(hookObject => {\n        return processHooks.call(service, hooks.finally, hookObject).catch(error => {\n          const errorHookObject = Object.assign({}, error.hook, {\n            error,\n            result: undefined\n          });\n          return errorHookObject;\n        });\n      }) // Resolve with a result or reject with an error\n      .then(hookObject => {\n        if (typeof hookObject.error !== 'undefined' && typeof hookObject.result === 'undefined') {\n          return Promise.reject(returnHook ? hookObject : hookObject.error);\n        } else {\n          return returnHook ? hookObject : hookObject.result;\n        }\n      });\n    };\n  };\n}; // A service mixin that adds `service.hooks()` method and functionality\n\n\nconst hookMixin = exports.hookMixin = function hookMixin(service) {\n  if (typeof service.hooks === 'function') {\n    return;\n  }\n\n  service.methods = Object.getOwnPropertyNames(service).filter(key => typeof service[key] === 'function' && service[key][ACTIVATE_HOOKS]).reduce((result, methodName) => {\n    result[methodName] = service[methodName][ACTIVATE_HOOKS];\n    return result;\n  }, service.methods || {});\n  Object.assign(service.methods, {\n    find: ['params'],\n    get: ['id', 'params'],\n    create: ['data', 'params'],\n    update: ['id', 'data', 'params'],\n    patch: ['id', 'data', 'params'],\n    remove: ['id', 'params']\n  });\n  const app = this;\n  const methodNames = Object.keys(service.methods); // Assemble the mixin object that contains all \"hooked\" service methods\n\n  const mixin = methodNames.reduce((mixin, method) => {\n    if (typeof service[method] !== 'function') {\n      return mixin;\n    }\n\n    mixin[method] = function () {\n      const service = this;\n      const args = Array.from(arguments);\n\n      const original = service._super.bind(service);\n\n      return withHooks({\n        app,\n        service,\n        method,\n        original\n      })({\n        before: getHooks(app, service, 'before', method),\n        after: getHooks(app, service, 'after', method, true),\n        error: getHooks(app, service, 'error', method, true),\n        finally: getHooks(app, service, 'finally', method, true)\n      })(...args);\n    };\n\n    return mixin;\n  }, {}); // Add .hooks method and properties to the service\n\n  enableHooks(service, methodNames, app.hookTypes);\n  service.mixin(mixin);\n};\n\nmodule.exports = function () {\n  return function (app) {\n    // We store a reference of all supported hook types on the app\n    // in case someone needs it\n    Object.assign(app, {\n      hookTypes: ['before', 'after', 'error', 'finally']\n    }); // Add functionality for hooks to be registered as app.hooks\n\n    enableHooks(app, app.methods, app.hookTypes);\n    app.mixins.push(hookMixin);\n  };\n};\n\nmodule.exports.withHooks = withHooks;\nmodule.exports.ACTIVATE_HOOKS = ACTIVATE_HOOKS;\n\nmodule.exports.activateHooks = function activateHooks(args) {\n  return fn => {\n    Object.defineProperty(fn, ACTIVATE_HOOKS, {\n      value: args\n    });\n    return fn;\n  };\n};","map":{"version":3,"sources":["/Users/parthjhaveri/Desktop/tile-geo/node_modules/@feathersjs/feathers/lib/hooks/index.js"],"names":["require","hooks","isPromise","baseHooks","createHookObject","getHooks","processHooks","enableHooks","ACTIVATE_HOOKS","withHooks","app","service","method","original","_hooks","hookTypes","reduce","result","type","value","Array","isArray","args","returnHook","length","pop","hookObject","arguments","Promise","resolve","then","call","concat","before","promise","func","methods","map","apply","Error","path","catch","error","hook","afterHookObject","Object","assign","after","errorHookObject","undefined","finally","reject","hookMixin","exports","getOwnPropertyNames","filter","key","methodName","find","get","create","update","patch","remove","methodNames","keys","mixin","from","_super","bind","module","mixins","push","activateHooks","fn","defineProperty"],"mappings":"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","sourcesContent":["const { hooks, isPromise } = require('@feathersjs/commons');\nconst baseHooks = require('./base');\n\nconst {\n  createHookObject,\n  getHooks,\n  processHooks,\n  enableHooks,\n  ACTIVATE_HOOKS\n} = hooks;\n\nconst withHooks = function withHooks ({\n  app,\n  service,\n  method,\n  original\n}) {\n  return (_hooks = {}) => {\n    const hooks = app.hookTypes.reduce((result, type) => {\n      const value = _hooks[type] || [];\n\n      result[type] = Array.isArray(value) ? value : [ value ];\n\n      return result;\n    }, {});\n\n    return function (...args) {\n      const returnHook = args[args.length - 1] === true\n        ? args.pop() : false;\n\n      // Create the hook object that gets passed through\n      const hookObject = createHookObject(method, {\n        type: 'before', // initial hook object type\n        arguments: args,\n        service,\n        app\n      });\n\n      return Promise.resolve(hookObject)\n\n        // Run `before` hooks\n        .then(hookObject => {\n          return processHooks.call(service, baseHooks.concat(hooks.before), hookObject);\n        })\n\n        // Run the original method\n        .then(hookObject => {\n          // If `hookObject.result` is set, skip the original method\n          if (typeof hookObject.result !== 'undefined') {\n            return hookObject;\n          }\n\n          // Otherwise, call it with arguments created from the hook object\n          const promise = new Promise(resolve => {\n            const func = original || service[method];\n            const args = service.methods[method].map((value) => hookObject[value]);\n            const result = func.apply(service, args);\n\n            if (!isPromise(result)) {\n              throw new Error(`Service method '${hookObject.method}' for '${hookObject.path}' service must return a promise`);\n            }\n\n            resolve(result);\n          });\n\n          return promise\n            .then(result => {\n              hookObject.result = result;\n              return hookObject;\n            })\n            .catch(error => {\n              error.hook = hookObject;\n              throw error;\n            });\n        })\n\n        // Run `after` hooks\n        .then(hookObject => {\n          const afterHookObject = Object.assign({}, hookObject, {\n            type: 'after'\n          });\n\n          return processHooks.call(service, hooks.after, afterHookObject);\n        })\n\n        // Run `errors` hooks\n        .catch(error => {\n          const errorHookObject = Object.assign({}, error.hook, {\n            type: 'error',\n            original: error.hook,\n            error,\n            result: undefined\n          });\n\n          return processHooks.call(service, hooks.error, errorHookObject)\n            .catch(error => {\n              const errorHookObject = Object.assign({}, error.hook, {\n                error,\n                result: undefined\n              });\n\n              return errorHookObject;\n            });\n        })\n\n        // Run `finally` hooks\n        .then(hookObject => {\n          return processHooks.call(service, hooks.finally, hookObject)\n            .catch(error => {\n              const errorHookObject = Object.assign({}, error.hook, {\n                error,\n                result: undefined\n              });\n\n              return errorHookObject;\n            });\n        })\n\n        // Resolve with a result or reject with an error\n        .then(hookObject => {\n          if (typeof hookObject.error !== 'undefined' && typeof hookObject.result === 'undefined') {\n            return Promise.reject(returnHook ? hookObject : hookObject.error);\n          } else {\n            return returnHook ? hookObject : hookObject.result;\n          }\n        });\n    };\n  };\n};\n\n// A service mixin that adds `service.hooks()` method and functionality\nconst hookMixin = exports.hookMixin = function hookMixin (service) {\n  if (typeof service.hooks === 'function') {\n    return;\n  }\n\n  service.methods = Object.getOwnPropertyNames(service)\n    .filter(key => typeof service[key] === 'function' && service[key][ACTIVATE_HOOKS])\n    .reduce((result, methodName) => {\n      result[methodName] = service[methodName][ACTIVATE_HOOKS];\n      return result;\n    }, service.methods || {});\n\n  Object.assign(service.methods, {\n    find: ['params'],\n    get: ['id', 'params'],\n    create: ['data', 'params'],\n    update: ['id', 'data', 'params'],\n    patch: ['id', 'data', 'params'],\n    remove: ['id', 'params']\n  });\n\n  const app = this;\n  const methodNames = Object.keys(service.methods);\n  // Assemble the mixin object that contains all \"hooked\" service methods\n  const mixin = methodNames.reduce((mixin, method) => {\n    if (typeof service[method] !== 'function') {\n      return mixin;\n    }\n\n    mixin[method] = function () {\n      const service = this;\n      const args = Array.from(arguments);\n      const original = service._super.bind(service);\n\n      return withHooks({\n        app,\n        service,\n        method,\n        original\n      })({\n        before: getHooks(app, service, 'before', method),\n        after: getHooks(app, service, 'after', method, true),\n        error: getHooks(app, service, 'error', method, true),\n        finally: getHooks(app, service, 'finally', method, true)\n      })(...args);\n    };\n\n    return mixin;\n  }, {});\n\n  // Add .hooks method and properties to the service\n  enableHooks(service, methodNames, app.hookTypes);\n\n  service.mixin(mixin);\n};\n\nmodule.exports = function () {\n  return function (app) {\n    // We store a reference of all supported hook types on the app\n    // in case someone needs it\n    Object.assign(app, {\n      hookTypes: ['before', 'after', 'error', 'finally']\n    });\n\n    // Add functionality for hooks to be registered as app.hooks\n    enableHooks(app, app.methods, app.hookTypes);\n\n    app.mixins.push(hookMixin);\n  };\n};\n\nmodule.exports.withHooks = withHooks;\n\nmodule.exports.ACTIVATE_HOOKS = ACTIVATE_HOOKS;\n\nmodule.exports.activateHooks = function activateHooks (args) {\n  return fn => {\n    Object.defineProperty(fn, ACTIVATE_HOOKS, { value: args });\n    return fn;\n  };\n};\n"]},"metadata":{},"sourceType":"script"}