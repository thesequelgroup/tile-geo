{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst errors_1 = require(\"@feathersjs/errors\");\n\nconst debug = debug_1.default('@feathersjs/transport-commons/client');\nconst namespacedEmitterMethods = ['addListener', 'emit', 'listenerCount', 'listeners', 'on', 'once', 'prependListener', 'prependOnceListener', 'removeAllListeners', 'removeListener'];\nconst otherEmitterMethods = ['eventNames', 'getMaxListeners', 'setMaxListeners'];\n\nconst addEmitterMethods = service => {\n  otherEmitterMethods.forEach(method => {\n    service[method] = function (...args) {\n      if (typeof this.connection[method] !== 'function') {\n        throw new Error(`Can not call '${method}' on the client service connection`);\n      }\n\n      return this.connection[method](...args);\n    };\n  }); // Methods that should add the namespace (service path)\n\n  namespacedEmitterMethods.forEach(method => {\n    service[method] = function (name, ...args) {\n      if (typeof this.connection[method] !== 'function') {\n        throw new Error(`Can not call '${method}' on the client service connection`);\n      }\n\n      const eventName = `${this.path} ${name}`;\n      debug(`Calling emitter method ${method} with ` + `namespaced event '${eventName}'`);\n      const result = this.connection[method](eventName, ...args);\n      return result === this.connection ? this : result;\n    };\n  });\n};\n\nclass Service {\n  constructor(options) {\n    this.events = options.events;\n    this.path = options.name;\n    this.connection = options.connection;\n    this.method = options.method;\n    this.timeout = options.timeout || 5000;\n    addEmitterMethods(this);\n  }\n\n  send(method, ...args) {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => reject(new errors_1.Timeout(`Timeout of ${this.timeout}ms exceeded calling ${method} on ${this.path}`, {\n        timeout: this.timeout,\n        method,\n        path: this.path\n      })), this.timeout);\n      args.unshift(method, this.path);\n      args.push(function (error, data) {\n        error = errors_1.convert(error);\n        clearTimeout(timeoutId);\n        return error ? reject(error) : resolve(data);\n      });\n      debug(`Sending socket.${this.method}`, args);\n      this.connection[this.method](...args);\n    });\n  }\n\n  find(params = {}) {\n    return this.send('find', params.query || {});\n  }\n\n  get(id, params = {}) {\n    return this.send('get', id, params.query || {});\n  }\n\n  create(data, params = {}) {\n    return this.send('create', data, params.query || {});\n  }\n\n  update(id, data, params = {}) {\n    return this.send('update', id, data, params.query || {});\n  }\n\n  patch(id, data, params = {}) {\n    return this.send('patch', id, data, params.query || {});\n  }\n\n  remove(id, params = {}) {\n    return this.send('remove', id, params.query || {});\n  } // `off` is actually not part of the Node event emitter spec\n  // but we are adding it since everybody is expecting it because\n  // of the emitter-component Socket.io is using\n\n\n  off(name, ...args) {\n    if (typeof this.connection.off === 'function') {\n      const result = this.connection.off(`${this.path} ${name}`, ...args);\n      return result === this.connection ? this : result;\n    } else if (args.length === 0) {\n      // @ts-ignore\n      return this.removeAllListeners(name);\n    } // @ts-ignore\n\n\n    return this.removeListener(name, ...args);\n  }\n\n}\n\nexports.Service = Service;","map":{"version":3,"sources":["../src/client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst debug_1 = __importDefault(require(\"debug\"));\nconst errors_1 = require(\"@feathersjs/errors\");\nconst debug = debug_1.default('@feathersjs/transport-commons/client');\nconst namespacedEmitterMethods = [\n    'addListener',\n    'emit',\n    'listenerCount',\n    'listeners',\n    'on',\n    'once',\n    'prependListener',\n    'prependOnceListener',\n    'removeAllListeners',\n    'removeListener'\n];\nconst otherEmitterMethods = [\n    'eventNames',\n    'getMaxListeners',\n    'setMaxListeners'\n];\nconst addEmitterMethods = (service) => {\n    otherEmitterMethods.forEach(method => {\n        service[method] = function (...args) {\n            if (typeof this.connection[method] !== 'function') {\n                throw new Error(`Can not call '${method}' on the client service connection`);\n            }\n            return this.connection[method](...args);\n        };\n    });\n    // Methods that should add the namespace (service path)\n    namespacedEmitterMethods.forEach(method => {\n        service[method] = function (name, ...args) {\n            if (typeof this.connection[method] !== 'function') {\n                throw new Error(`Can not call '${method}' on the client service connection`);\n            }\n            const eventName = `${this.path} ${name}`;\n            debug(`Calling emitter method ${method} with ` +\n                `namespaced event '${eventName}'`);\n            const result = this.connection[method](eventName, ...args);\n            return result === this.connection ? this : result;\n        };\n    });\n};\nclass Service {\n    constructor(options) {\n        this.events = options.events;\n        this.path = options.name;\n        this.connection = options.connection;\n        this.method = options.method;\n        this.timeout = options.timeout || 5000;\n        addEmitterMethods(this);\n    }\n    send(method, ...args) {\n        return new Promise((resolve, reject) => {\n            const timeoutId = setTimeout(() => reject(new errors_1.Timeout(`Timeout of ${this.timeout}ms exceeded calling ${method} on ${this.path}`, {\n                timeout: this.timeout,\n                method,\n                path: this.path\n            })), this.timeout);\n            args.unshift(method, this.path);\n            args.push(function (error, data) {\n                error = errors_1.convert(error);\n                clearTimeout(timeoutId);\n                return error ? reject(error) : resolve(data);\n            });\n            debug(`Sending socket.${this.method}`, args);\n            this.connection[this.method](...args);\n        });\n    }\n    find(params = {}) {\n        return this.send('find', params.query || {});\n    }\n    get(id, params = {}) {\n        return this.send('get', id, params.query || {});\n    }\n    create(data, params = {}) {\n        return this.send('create', data, params.query || {});\n    }\n    update(id, data, params = {}) {\n        return this.send('update', id, data, params.query || {});\n    }\n    patch(id, data, params = {}) {\n        return this.send('patch', id, data, params.query || {});\n    }\n    remove(id, params = {}) {\n        return this.send('remove', id, params.query || {});\n    }\n    // `off` is actually not part of the Node event emitter spec\n    // but we are adding it since everybody is expecting it because\n    // of the emitter-component Socket.io is using\n    off(name, ...args) {\n        if (typeof this.connection.off === 'function') {\n            const result = this.connection.off(`${this.path} ${name}`, ...args);\n            return result === this.connection ? this : result;\n        }\n        else if (args.length === 0) {\n            // @ts-ignore\n            return this.removeAllListeners(name);\n        }\n        // @ts-ignore\n        return this.removeListener(name, ...args);\n    }\n}\nexports.Service = Service;\n//# sourceMappingURL=client.js.map"]},"metadata":{},"sourceType":"script"}